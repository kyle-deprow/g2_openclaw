#!/usr/bin/env node
/**
 * BYOK Coordination Script
 *
 * Reads provider config from OpenClaw and generates a coordinated .env
 * for the Copilot Bridge, ensuring both platforms use the same provider.
 *
 * Supported providers: OpenAI, Anthropic, Azure OpenAI, Ollama
 *
 * Model recommendations:
 *   - Coding tasks: GPT-4o, Claude 3.5 Sonnet, Codestral
 *   - Conversation: GPT-4o-mini, Claude 3 Haiku
 *   - Local: Ollama with CodeLlama or DeepSeek Coder
 *
 * Usage: npx tsx scripts/setup-byok.ts [--provider openai|anthropic|azure|ollama]
 */
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

interface OpenClawConfig {
	llm?: {
		provider?: string;
		model?: string;
		api_key?: string;
		base_url?: string;
		azure?: {
			api_version?: string;
			deployment?: string;
			endpoint?: string;
		};
	};
}

interface ByokMapping {
	COPILOT_BYOK_PROVIDER: string;
	COPILOT_BYOK_API_KEY?: string;
	COPILOT_BYOK_BASE_URL?: string;
	COPILOT_BYOK_MODEL?: string;
}

const PROVIDER_MAP: Record<string, string> = {
	openai: "openai",
	anthropic: "anthropic",
	azure_openai: "azure",
	azure: "azure",
	ollama: "ollama",
};

const DEFAULT_MODELS: Record<string, string> = {
	openai: "gpt-4o",
	anthropic: "claude-sonnet-4-20250514",
	azure: "gpt-4o",
	ollama: "codellama",
};

const DEFAULT_BASE_URLS: Record<string, string> = {
	ollama: "http://localhost:11434",
};

async function readOpenClawConfig(): Promise<OpenClawConfig | null> {
	const homeDir = process.env.HOME ?? process.env.USERPROFILE ?? "/tmp";
	const configPath = path.join(homeDir, ".openclaw", "config");
	try {
		const raw = await fs.readFile(configPath, "utf-8");
		return JSON.parse(raw) as OpenClawConfig;
	} catch {
		return null;
	}
}

function mapToByok(config: OpenClawConfig, overrideProvider?: string): ByokMapping | null {
	const llm = config.llm;
	if (!llm) return null;

	const rawProvider = overrideProvider ?? llm.provider;
	if (!rawProvider) return null;

	const mappedProvider = PROVIDER_MAP[rawProvider.toLowerCase()];
	if (!mappedProvider) {
		console.error(
			`Unsupported provider: "${rawProvider}". Supported: ${Object.keys(PROVIDER_MAP).join(", ")}`,
		);
		return null;
	}

	const mapping: ByokMapping = {
		COPILOT_BYOK_PROVIDER: mappedProvider,
	};

	// API key
	if (llm.api_key) {
		mapping.COPILOT_BYOK_API_KEY = llm.api_key;
	}

	// Base URL
	if (llm.base_url) {
		mapping.COPILOT_BYOK_BASE_URL = llm.base_url;
	} else if (mappedProvider === "azure" && llm.azure?.endpoint) {
		mapping.COPILOT_BYOK_BASE_URL = llm.azure.endpoint;
	} else if (DEFAULT_BASE_URLS[mappedProvider]) {
		mapping.COPILOT_BYOK_BASE_URL = DEFAULT_BASE_URLS[mappedProvider];
	}

	// Model
	mapping.COPILOT_BYOK_MODEL = llm.model ?? DEFAULT_MODELS[mappedProvider];

	return mapping;
}

async function writeEnvFile(mapping: ByokMapping): Promise<string> {
	const moduleDir = path.dirname(fileURLToPath(import.meta.url));
	const envPath = path.join(moduleDir, "..", ".env");

	// Read existing .env to preserve non-BYOK vars
	let existingLines: string[] = [];
	try {
		const existing = await fs.readFile(envPath, "utf-8");
		existingLines = existing.split("\n").filter((line) => !line.startsWith("COPILOT_BYOK_"));
		// Remove trailing empty lines
		while (existingLines.length > 0 && existingLines[existingLines.length - 1]?.trim() === "") {
			existingLines.pop();
		}
	} catch {
		// No existing .env
	}

	const byokLines = [
		"",
		"# BYOK Configuration (auto-generated by setup-byok.ts)",
		`COPILOT_BYOK_PROVIDER=${mapping.COPILOT_BYOK_PROVIDER}`,
	];
	if (mapping.COPILOT_BYOK_API_KEY) {
		byokLines.push(`COPILOT_BYOK_API_KEY=${mapping.COPILOT_BYOK_API_KEY}`);
	}
	if (mapping.COPILOT_BYOK_BASE_URL) {
		byokLines.push(`COPILOT_BYOK_BASE_URL=${mapping.COPILOT_BYOK_BASE_URL}`);
	}
	if (mapping.COPILOT_BYOK_MODEL) {
		byokLines.push(`COPILOT_BYOK_MODEL=${mapping.COPILOT_BYOK_MODEL}`);
	}

	const content = [...existingLines, ...byokLines, ""].join("\n");
	await fs.writeFile(envPath, content, "utf-8");
	return envPath;
}

async function main(): Promise<void> {
	const args = process.argv.slice(2);
	const providerIdx = args.indexOf("--provider");
	const overrideProvider = providerIdx >= 0 ? args[providerIdx + 1] : undefined;

	console.log("ðŸ”§ BYOK Coordination Setup");
	console.log("==========================\n");

	// Step 1: Read OpenClaw config
	console.log("Reading OpenClaw config...");
	const config = await readOpenClawConfig();

	if (!config) {
		console.log("No OpenClaw config found at ~/.openclaw/config");
		if (!overrideProvider) {
			console.log("Use --provider <name> to set up manually");
			process.exit(1);
		}
		// Create minimal config from override
		const mapping: ByokMapping = {
			COPILOT_BYOK_PROVIDER: PROVIDER_MAP[overrideProvider] ?? overrideProvider,
			COPILOT_BYOK_MODEL: DEFAULT_MODELS[PROVIDER_MAP[overrideProvider] ?? overrideProvider],
		};
		if (DEFAULT_BASE_URLS[mapping.COPILOT_BYOK_PROVIDER]) {
			mapping.COPILOT_BYOK_BASE_URL = DEFAULT_BASE_URLS[mapping.COPILOT_BYOK_PROVIDER];
		}
		const envPath = await writeEnvFile(mapping);
		console.log(`âœ… Wrote ${envPath}`);
		console.log("âš ï¸  Set COPILOT_BYOK_API_KEY in .env manually");
		return;
	}

	console.log(`  Provider: ${config.llm?.provider ?? "not set"}`);
	console.log(`  Model: ${config.llm?.model ?? "not set"}`);

	// Step 2: Map to BYOK format
	const mapping = mapToByok(config, overrideProvider);
	if (!mapping) {
		console.error("âŒ Could not map OpenClaw config to BYOK format");
		process.exit(1);
	}

	console.log("\nMapped BYOK config:");
	console.log(`  Provider: ${mapping.COPILOT_BYOK_PROVIDER}`);
	console.log(`  Model: ${mapping.COPILOT_BYOK_MODEL ?? "default"}`);
	console.log(`  Base URL: ${mapping.COPILOT_BYOK_BASE_URL ?? "default"}`);
	console.log(`  API Key: ${mapping.COPILOT_BYOK_API_KEY ? "***" : "not set"}`);

	// Step 3: Write .env
	const envPath = await writeEnvFile(mapping);
	console.log(`\nâœ… Wrote ${envPath}`);

	// Step 4: Validate
	console.log("\nValidating config...");
	try {
		const { loadConfig } = await import("../src/config.js");
		const loaded = loadConfig();
		if (loaded.byokProvider === mapping.COPILOT_BYOK_PROVIDER) {
			console.log("âœ… Config validated: provider matches");
		} else {
			console.log(
				`âš ï¸  Provider mismatch: expected ${mapping.COPILOT_BYOK_PROVIDER}, got ${loaded.byokProvider}`,
			);
		}
	} catch (err) {
		console.error(
			`âš ï¸  Config validation failed: ${err instanceof Error ? err.message : String(err)}`,
		);
	}

	console.log("\nðŸ“‹ Model Recommendations:");
	console.log("  Coding tasks: GPT-4o, Claude 3.5 Sonnet, Codestral");
	console.log("  Conversation: GPT-4o-mini, Claude 3 Haiku");
	console.log("  Local: Ollama with CodeLlama or DeepSeek Coder");
}

if (import.meta.url === `file://${process.argv[1]}`) {
	main().catch((err) => {
		console.error("Fatal:", err);
		process.exit(1);
	});
}

// Exports for testing
export { readOpenClawConfig, mapToByok, writeEnvFile, PROVIDER_MAP, DEFAULT_MODELS };
export type { OpenClawConfig, ByokMapping };
